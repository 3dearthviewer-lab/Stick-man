<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Stickman Motion Tracker</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    canvas, video {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #status {
      position: absolute;
      top: 10px;
      left: 10px;
      color: lime;
      font-family: sans-serif;
      font-size: 14px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="status">Loading...</div>
  <video id="video" autoplay muted playsinline></video>
  <canvas id="canvas"></canvas>

  <script type="module">
    import { PoseLandmarker, FilesetResolver } from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0";

    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const status = document.getElementById("status");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    async function startCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
      video.srcObject = stream;
      await video.play();
    }

    async function initPose() {
      const filesetResolver = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );

      const poseLandmarker = await PoseLandmarker.createFromOptions(filesetResolver, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO",
        numPoses: 1
      });

      return poseLandmarker;
    }

    // Previous frame landmarks for smoothing
    let prevLandmarks = null;
    const smoothing = 0.3; // 0-1, higher = slower, smoother

    function interpolateLandmarks(prev, next) {
      if (!prev) return next.map(p => ({x: p.x, y: p.y}));
      return next.map((p, i) => ({
        x: prev[i].x + (p.x - prev[i].x) * smoothing,
        y: prev[i].y + (p.y - prev[i].y) * smoothing
      }));
    }

    function drawStickman(landmarks) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const scale = Math.min(canvas.width / video.videoWidth, canvas.height / video.videoHeight);
      const offsetX = (canvas.width - video.videoWidth * scale) / 2;
      const offsetY = (canvas.height - video.videoHeight * scale) / 2;

      const getPoint = i => {
        const p = landmarks[i];
        return {
          x: offsetX + p.x * video.videoWidth * scale,
          y: offsetY + p.y * video.videoHeight * scale
        };
      };

      const connections = [
        [11,12], [11,13], [13,15], [15,17], [15,19], [15,21], [17,19],
        [12,14], [14,16], [16,18], [16,20], [16,22], [18,20],
        [11,23], [12,24], [23,24], [23,25], [25,27], [27,29], [27,31],
        [24,26], [26,28], [28,30], [28,32], [30,32]
      ];

      ctx.strokeStyle = "cyan";
      ctx.lineWidth = 3;
      ctx.lineCap = "round";

      for (const [a, b] of connections) {
        const p1 = getPoint(a);
        const p2 = getPoint(b);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }

      ctx.fillStyle = "white";
      landmarks.forEach((_, i) => {
        const p = getPoint(i);
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
        ctx.fill();
      });
    }

    async function main() {
      await startCamera();
      const poseLandmarker = await initPose();

      video.addEventListener("loadedmetadata", () => {
        let lastTime = 0;

        async function predict(time) {
          if (time - lastTime > 33) { // ~30 FPS
            lastTime = time;
            const results = await poseLandmarker.detectForVideo(video, performance.now());

            if (results.landmarks && results.landmarks.length > 0) {
              const smoothed = interpolateLandmarks(prevLandmarks, results.landmarks[0]);
              drawStickman(smoothed);
              prevLandmarks = smoothed;
              status.textContent = "Tracking...";
            } else {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              status.textContent = "No body detected";
            }
          }
          requestAnimationFrame(predict);
        }
        requestAnimationFrame(predict);
      });
    }

    main();
  </script>
</body>
</html>
